"""
FastAPI Code Generator
=====================

Generate FastAPI applications from Python function definitions.
Creates REST endpoints with automatic parameter handling and documentation.
"""

from typing import Any, Dict, List, Tuple, Optional
import json


# Template for the generated FastAPI app
FASTAPI_TEMPLATE = '''"""
Auto-generated FastAPI application
=================================

This file was automatically generated by SwaggerMCP.
Do not edit manually - changes will be overwritten on regeneration.

Generated from: {source_info}
"""

from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import JSONResponse
from typing import Any, Dict, List, Optional, Union
import json
import traceback

# Create FastAPI app
app = FastAPI(
    title="{app_title}",
    description="{app_description}",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# Parameter coercion function
def _coerce_parameter(value: Any, expected_type: str = None) -> Any:
    """
    Coerce a parameter value to the appropriate type.
    
    Args:
        value: The value to coerce
        expected_type: Expected type hint (optional)
    
    Returns:
        Coerced value
    """
    if value is None:
        return None
    
    # If it's already the right type, return as is
    if expected_type:
        try:
            if expected_type == "int" and isinstance(value, (int, str)):
                return int(value)
            elif expected_type == "float" and isinstance(value, (int, float, str)):
                return float(value)
            elif expected_type == "bool" and isinstance(value, (bool, str)):
                if isinstance(value, str):
                    return value.lower() in ("true", "1", "yes", "on")
                return bool(value)
            elif expected_type == "str":
                return str(value)
            elif expected_type == "list" and isinstance(value, str):
                return json.loads(value)
            elif expected_type == "dict" and isinstance(value, str):
                return json.loads(value)
        except (ValueError, TypeError, json.JSONDecodeError):
            pass
    
    # Fallback coercion
    try:
        # Try int
        if isinstance(value, str) and value.replace("-", "").replace(".", "").isdigit():
            if "." in value:
                return float(value)
            return int(value)
    except (ValueError, TypeError):
        pass
    
    try:
        # Try bool
        if isinstance(value, str):
            if value.lower() in ("true", "false", "1", "0", "yes", "no"):
                return value.lower() in ("true", "1", "yes")
    except (ValueError, TypeError):
        pass
    
    try:
        # Try JSON
        if isinstance(value, str) and (value.startswith("[") or value.startswith("{")):
            return json.loads(value)
    except (ValueError, TypeError, json.JSONDecodeError):
        pass
    
    # Return as string
    return str(value)

# User functions
{user_functions}

# Generated endpoints
{endpoints}
'''


def _generate_parameter_handling(func_def: Dict[str, Any]) -> Tuple[str, str]:
    """
    Generate parameter handling code for a function.
    
    Args:
        func_def: Function definition dictionary
        
    Returns:
        Tuple of (parameter signature, parameter processing code)
    """
    name = func_def["name"]
    args = func_def.get("args", [])
    type_hints = func_def.get("type_hints", {})
    defaults = func_def.get("defaults", {})
    
    # Build FastAPI parameter signature
    param_signature_parts = []
    param_processing_parts = []
    
    for arg in args:
        # Determine parameter type for FastAPI
        param_type = "Any"
        if arg in type_hints:
            type_hint = type_hints[arg]
            if "int" in type_hint.lower():
                param_type = "int"
            elif "float" in type_hint.lower():
                param_type = "float"
            elif "bool" in type_hint.lower():
                param_type = "bool"
            elif "list" in type_hint.lower():
                param_type = "List"
            elif "dict" in type_hint.lower():
                param_type = "Dict"
            else:
                param_type = "str"
        
        # Add to signature
        if arg in defaults:
            param_signature_parts.append(f"{arg}: {param_type} = None")
        else:
            param_signature_parts.append(f"{arg}: {param_type}")
        
        # Add to processing
        if arg in defaults:
            param_processing_parts.append(
                f"    {arg} = _coerce_parameter({arg}, '{type_hints.get(arg, '')}') if {arg} is not None else {defaults[arg]}"
            )
        else:
            param_processing_parts.append(
                f"    {arg} = _coerce_parameter({arg}, '{type_hints.get(arg, '')}')"
            )
    
    param_signature = ", ".join(param_signature_parts)
    param_processing = "\n".join(param_processing_parts)
    
    return param_signature, param_processing


def _generate_endpoint_code(func_def: Dict[str, Any]) -> str:
    """
    Generate FastAPI endpoint code for a function.
    
    Args:
        func_def: Function definition dictionary
        
    Returns:
        Generated endpoint code
    """
    name = func_def["name"]
    args = func_def.get("args", [])
    docstring = func_def.get("docstring", "")
    
    # Generate parameter handling
    param_signature, param_processing = _generate_parameter_handling(func_def)
    
    # Build function call
    arg_list = ", ".join(args) if args else ""
    
    # Generate endpoint code
    endpoint_code = f'''
@app.post("/{name}", summary="{name}", description="{docstring}")
async def {name}_endpoint({param_signature}):
    """
    Endpoint for {name} function.
    
    {docstring}
    """
    try:
{param_processing}
        
        # Call the function
        result = {name}({arg_list})
        
        return {{"result": result, "success": True}}
        
    except Exception as e:
        return JSONResponse(
            status_code=500,
            content={{
                "error": str(e),
                "success": False,
                "function": "{name}"
            }}
        )
'''
    
    return endpoint_code


def generate_fastapi_app_source(
    raw_source: str,
    functions: List[Dict[str, Any]],
    app_title: str = "Generated API",
    app_description: str = "Auto-generated API from Python functions"
) -> Tuple[str, List[str]]:
    """
    Generate FastAPI application source code from function definitions.
    
    Args:
        raw_source: Original Python source code
        functions: List of function definition dictionaries
        app_title: Title for the FastAPI app
        app_description: Description for the FastAPI app
        
    Returns:
        Tuple of (generated source code, list of endpoint paths)
    """
    if not functions:
        raise ValueError("No functions provided for API generation")
    
    # Generate user functions section
    user_functions = f"# User-provided functions\n{raw_source}\n"
    
    # Generate endpoints
    endpoints = []
    endpoint_code_parts = []
    
    for func_def in functions:
        name = func_def["name"]
        endpoint_path = f"/{name}"
        endpoints.append(endpoint_path)
        
        endpoint_code = _generate_endpoint_code(func_def)
        endpoint_code_parts.append(endpoint_code)
    
    # Combine all parts
    generated_source = FASTAPI_TEMPLATE.format(
        source_info="Python functions",
        app_title=app_title,
        app_description=app_description,
        user_functions=user_functions,
        endpoints="\n".join(endpoint_code_parts)
    )
    
    return generated_source, endpoints


def generate_openapi_spec(functions: List[Dict[str, Any]], 
                         app_title: str = "Generated API") -> Dict[str, Any]:
    """
    Generate OpenAPI specification for the functions.
    
    Args:
        functions: List of function definition dictionaries
        app_title: Title for the API
        
    Returns:
        OpenAPI specification dictionary
    """
    spec = {
        "openapi": "3.0.0",
        "info": {
            "title": app_title,
            "version": "1.0.0",
            "description": "Auto-generated API from Python functions"
        },
        "paths": {},
        "components": {
            "schemas": {
                "Error": {
                    "type": "object",
                    "properties": {
                        "error": {"type": "string"},
                        "success": {"type": "boolean"},
                        "function": {"type": "string"}
                    }
                },
                "Success": {
                    "type": "object",
                    "properties": {
                        "result": {"type": "object"},
                        "success": {"type": "boolean"}
                    }
                }
            }
        }
    }
    
    for func_def in functions:
        name = func_def["name"]
        args = func_def.get("args", [])
        docstring = func_def.get("docstring", "")
        type_hints = func_def.get("type_hints", {})
        
        # Generate parameter schema
        parameters = []
        for arg in args:
            param_schema = {
                "name": arg,
                "in": "query",
                "required": arg not in func_def.get("defaults", {}),
                "schema": {"type": "string"}
            }
            
            # Add type hint if available
            if arg in type_hints:
                param_schema["description"] = f"Type: {type_hints[arg]}"
            
            parameters.append(param_schema)
        
        # Add endpoint to paths
        spec["paths"][f"/{name}"] = {
            "post": {
                "summary": name,
                "description": docstring or f"Endpoint for {name} function",
                "parameters": parameters,
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": {
                                "schema": {"$ref": "#/components/schemas/Success"}
                            }
                        }
                    },
                    "500": {
                        "description": "Error response",
                        "content": {
                            "application/json": {
                                "schema": {"$ref": "#/components/schemas/Error"}
                            }
                        }
                    }
                }
            }
        }
    
    return spec


def validate_generated_code(source_code: str) -> List[str]:
    """
    Validate generated FastAPI code for common issues.
    
    Args:
        source_code: Generated source code
        
    Returns:
        List of validation warnings/errors
    """
    issues = []
    
    # Check for basic syntax
    try:
        compile(source_code, "<generated>", "exec")
    except SyntaxError as e:
        issues.append(f"Syntax error in generated code: {e}")
    
    # Check for common issues
    if "from fastapi import" not in source_code:
        issues.append("Missing FastAPI import")
    
    if "app = FastAPI(" not in source_code:
        issues.append("Missing FastAPI app creation")
    
    if "@app.post(" not in source_code:
        issues.append("No POST endpoints generated")
    
    return issues 